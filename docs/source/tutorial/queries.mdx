---
title: "Fetch data with queries"
sidebar_title: "7. Fetch data with queries"
description: Working with the useQuery React Hook
---

import { MultiCodeBlock } from 'gatsby-theme-apollo-docs';
import Disclaimer from '../../shared/disclaimer.mdx';

Time to accomplish: _15 Minutes_

Now that we've [set up Apollo Client](./client/), we can integrate it into our React app. This lets us use [React Hooks](https://reactjs.org/docs/hooks-intro.html) to bind the results of GraphQL queries directly to our UI.

<Disclaimer />

## Integrate with React

To connect Apollo Client to React, we wrap our app in the `ApolloProvider` component from the `@apollo/client` package. We pass our `ApolloClient` instance to the `ApolloProvider` component via the `client` prop.

Open `src/index.tsx` and update it to match the following:

<MultiCodeBlock>

```tsx:title=src/index.tsx
import {
  ApolloClient,
  InMemoryCache,
  NormalizedCacheObject,
  ApolloProvider
} from '@apollo/client';
import React from 'react';
import ReactDOM from 'react-dom';
import Pages from './pages';
import injectStyles from './styles';

// Initialize ApolloClient
const client: ApolloClient<NormalizedCacheObject> = new ApolloClient({
  uri: 'http://localhost:4000/',
  cache: new InMemoryCache()
});

injectStyles();

// Pass the ApolloClient instance to the ApolloProvider component
ReactDOM.render(
  <ApolloProvider client={client}>
    <Pages />
  </ApolloProvider>,
  document.getElementById('root')
);
```

</MultiCodeBlock>

The `ApolloProvider` component is similar to Reactâ€™s context provider: it wraps your React app and places `client` on the context, which enables you to access it from anywhere in your component tree.

Now we're ready to build React components that execute GraphQL queries.


## Display a list of launches

Let's build the page in our app that shows a list of available SpaceX launches. Open `src/pages/launches.tsx`. Right now, the file  looks like this:

<MultiCodeBlock>

```tsx:title=src/pages/launches.tsx
import React, { Fragment }  from 'react';
import { RouteComponentProps } from '@reach/router';
import { gql } from '@apollo/client'

export const LAUNCH_TILE_DATA = gql`
  fragment LaunchTile on Launch {
    __typename
    id
    isBooked
    rocket {
      id
      name
    }
    mission {
      name
      missionPatch
    }
  }
`;

interface LaunchesProps extends RouteComponentProps {}

const Launches: React.FC<LaunchesProps> = () => {
  return <div />;
}

export default Launches;
```

</MultiCodeBlock>

### Define the query

First, we'll define the shape of the query we'll use to fetch a paginated list of launches. Paste the following directly below the declaration of `LAUNCH_TILE_DATA`:

```js{7,11}:title=src/pages/launches.tsx
export const GET_LAUNCHES = gql`
  query GetLaunchList($after: String) {
    launches(after: $after) {
      cursor
      hasMore
      launches {
        ...LaunchTile
      }
    }
  }
  ${LAUNCH_TILE_DATA}
`;
```

#### Using fragments

Our query definition pulls in the `LAUNCH_TILE_DATA` definition above it. `LAUNCH_TILE_DATA` defines a GraphQL [fragment](https://graphql.org/learn/queries/#fragments) named `LaunchTile`. A fragment is useful for defining a set of fields that you want to include across multiple queries so you don't have to rewrite them.

In the query above, we include the `LaunchTile` fragment in our query by preceding it with `...`, similar to JavaScript [spread syntax](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax).


#### Pagination details

Notice that in addition to fetching a list of `launches`, our query fetches `hasMore` and `cursor` fields. That's because the `launches` query returns **paginated results**:


* The `hasMore` field indicates whether there are additional launches beyond the list returned by the server.
* The `cursor` field indicates the client's current position within the list of launches. We can execute the query again and provide our most recent `cursor` as the value of the `$after` argument to fetch the _next_ set of launches in the list.


### Apply the `useQuery` hook

We'll use Apollo Client's `useQuery` [React Hook](https://reactjs.org/docs/hooks-intro.html) to execute our new query within the `Launches` component. The hook's result object provides properties that help us populate and render our component throughout the query's execution lifecycle.

1. Modify your `@apollo/client` import to include `useQuery`, and import a few components for rendering the page:

  ```js:title=src/pages/launches.tsx
  import { gql, useQuery } from '@apollo/client';
  import { LaunchTile, Header, Button, Loading } from '../components';
  ```

2. Replace the placeholder declaration of `const Launches` with the following:

  <MultiCodeBlock>

  ```tsx:title=src/pages/launches.tsx
  const Launches: React.FC<LaunchesProps> = () => {
    const {
      data,
      loading,
      error
    } = useQuery<
      GetLaunchListTypes.GetLaunchList,
      GetLaunchListTypes.GetLaunchListVariables
    >(GET_LAUNCHES);

    if (loading) return <Loading />;
    if (error) return <p>ERROR</p>;
    if (!data) return <p>Not found</p>;

    return (
      <Fragment>
        <Header />
        {data.launches &&
          data.launches.launches &&
          data.launches.launches.map((launch: any) => (
            <LaunchTile key={launch.id} launch={launch} />
          ))}
      </Fragment>
    );
  }
  ```

  </MultiCodeBlock>

This component passes our `GET_LAUNCHES` query to `useQuery` and obtains `data`, `loading`, and `error` properties from the result. Depending on the state of those properties, we render a list of launches, a loading indicator, or an error message.

Because our `launches` query returns paginated results, we're not done yet! Right now, our query fetches only the first 20 launches from the list. To be able to fetch the _full_ list of launches, we need to modify our code to use the `cursor` and `hasMore` fields included in our query. Let's learn how!

### Add pagination support

> Apollo Client 3 provides a new API for Relay-style pagination that is not yet documented. For details, see [this pull request](https://github.com/apollographql/apollo-client/pull/6465).

Apollo Client provides a `fetchMore` helper function to assist with paginated queries. Add `fetchMore` to the list of objects we destructure from the `useQuery` result object:

<MultiCodeBlock>

```tsx:title=src/pages/launches.tsx
const Launches: React.FC<LaunchesProps> = () => {
  const {
    data,
    loading,
    error,
    fetchMore // highlight-line
  } = useQuery<
    GetLaunchListTypes.GetLaunchList,
    GetLaunchListTypes.GetLaunchListVariables
  >(GET_LAUNCHES);
  // same as above
}
```

</MultiCodeBlock>

We can connect `fetchMore` to a button in our UI that fetches additional launches when it's clicked. To support this behavior, we need to define an `updateQuery` function on the return object from `fetchMore`. This function tells the Apollo Client cache how to combine the new results with the results we already have. 

Paste the code below directly above the closing `</Fragment>` tag in the `Launches` component:

<MultiCodeBlock>

```tsx:title=src/pages/launches.tsx
{data.launches &&
  data.launches.hasMore && (
    <Button
      onClick={() =>
        fetchMore({ // highlight-line
          variables: {
            after: data.launches.cursor,
          },
          updateQuery: (prev, { fetchMoreResult, ...rest }) => { // highlight-line
            if (!fetchMoreResult) return prev;
            return {
              ...fetchMoreResult,
              launches: {
                ...fetchMoreResult.launches,
                launches: [
                  ...prev.launches.launches,
                  ...fetchMoreResult.launches.launches,
                ],
              },
            };
          },
        })
      }
    >
      Load More
    </Button>
  )
}
//</Fragment>
```

```jsx:title=src/pages/launches.jsx
{data.launches &&
  data.launches.hasMore && (
    <Button
      onClick={() =>
        fetchMore({ // highlight-line
          variables: {
            after: data.launches.cursor,
          },
          updateQuery: (prev, { fetchMoreResult, ...rest }) => { // highlight-line
            if (!fetchMoreResult) return prev;
            return {
              ...fetchMoreResult,
              launches: {
                ...fetchMoreResult.launches,
                launches: [
                  ...prev.launches.launches,
                  ...fetchMoreResult.launches.launches,
                ],
              },
            };
          },
        })
      }
    >
      Load More
    </Button>
  )
}
//</Fragment>
```

</MultiCodeBlock>

Here's a summary of the logic above:

1. We check to see if more launches are available from the server.

2. If so, we render a button with a click handler that calls the `fetchMore` helper function.

3. When it's called, the `fetchMore` function is passed our most recent `cursor` as a variable for the `launches` query.

4. When the followup query returns results, the `updateQuery` function is called. It's passed both our existing cached query result (`prev`) and the newly returned result (`fetchMoreResult`).

5. The `updateQuery` function returns the object that replaces `prev`, the existing result in the cache.

In the next step, we'll wire up a launch detail page that displays a single launch when an item in our paginated list is clicked.

## Display a single launch's details

Let's navigate to `src/pages/launch.tsx` to build out our detail page. First, we should import some components and define our GraphQL query to get the launch details.

<MultiCodeBlock>

```tsx:title=src/pages/launch.tsx
import React, { Fragment } from 'react'; // preserve-line
import { gql, useQuery } from '@apollo/client'; // preserve-line

import { Loading, Header, LaunchDetail } from '../components'; // preserve-line
import { ActionButton } from '../containers'; // preserve-line
import { RouteComponentProps } from '@reach/router';
import * as LaunchDetailsTypes from './__generated__/LaunchDetails';

export const GET_LAUNCH_DETAILS = gql`
  query LaunchDetails($launchId: ID!) {
    launch(id: $launchId) {
      id
      site
      isBooked
      rocket {
        id
        name
        type
      }
      mission {
        name
        missionPatch
      }
    }
  }
`;
```

</MultiCodeBlock>

Now that we have a query, let's render a component with `useQuery` to execute it. This time, we'll also need to pass in the `launchId` as a variable to the query, which we'll do by adding a `variables` option to `useQuery`. The `launchId` comes through as a prop from the router.

<MultiCodeBlock>

```tsx:title=src/pages/launch.tsx
interface LaunchProps extends RouteComponentProps {
  launchId?: any;
}

const Launch: React.FC<LaunchProps> = ({ launchId }) => {
  const {
    data,
    loading,
    error
  } = useQuery<
    LaunchDetailsTypes.LaunchDetails,
    LaunchDetailsTypes.LaunchDetailsVariables
  >(GET_LAUNCH_DETAILS,
    { variables: { launchId } }
  );

  if (loading) return <Loading />;
  if (error) return <p>ERROR: {error.message}</p>;
  if (!data) return <p>Not found</p>;

  return (
    <Fragment>
      <Header image={data.launch && data.launch.mission && data.launch.mission.missionPatch}>
        {data && data.launch && data.launch.mission && data.launch.mission.name}
      </Header>
      <LaunchDetail {...data.launch} />
      <ActionButton {...data.launch} />
    </Fragment>
  );
}

export default Launch;
```

</MultiCodeBlock>

Just like before, we use the status of the query to render either a `loading` or `error` state, or data when the query completes.

### Using fragments to share code

You may have noticed that the queries for fetching a list of launches and fetching a launch detail share a lot of the same fields. When we have two GraphQL operations that contain the same fields, we can use a **fragment** to share fields between the two.

To learn how to build a fragment, navigate to `src/pages/launches.tsx` and copy the code below into the file:

<MultiCodeBlock>

```tsx:title=src/pages/launches.tsx
export const LAUNCH_TILE_DATA = gql`
  fragment LaunchTile on Launch {
    id
    isBooked
    rocket {
      id
      name
    }
    mission {
      name
      missionPatch
    }
  }
`;
```

</MultiCodeBlock>

We define a GraphQL fragment by giving it a name (`LaunchTile`) and defining it on a type on our schema (`Launch`). The name we give our fragment can be anything, but the type must correspond to a type in our schema.

To use our fragment in our query, we import it into the GraphQL document and use the spread operator to spread the fields into our query:

<MultiCodeBlock>

```tsx{7}:title=src/pages/launches.tsx
const GET_LAUNCHES = gql`
  query launchList($after: String) {
    launches(after: $after) {
      cursor
      hasMore
      launches {
        ...LaunchTile
      }
    }
  }
  ${LAUNCH_TILE_DATA}
`;
```

</MultiCodeBlock>

Let's use our fragment in our launch detail query too. Be sure to import the fragment from the `launches` page before you use it:

<MultiCodeBlock>

```tsx:title=src/pages/launch.tsx
import { LAUNCH_TILE_DATA } from './launches';

export const GET_LAUNCH_DETAILS = gql`
  query LaunchDetails($launchId: ID!) {
    launch(id: $launchId) {
      site
      rocket {
        type
      }
      ...LaunchTile
    }
  }
  ${LAUNCH_TILE_DATA}
`;
```

</MultiCodeBlock>

Great, now we've successfully refactored our queries to use fragments. Fragments are a helpful tool that you'll use a lot as you're building GraphQL queries and mutations.

### Customizing the fetch policy

Sometimes, it's useful to tell Apollo Client to bypass the cache altogether if you have some data that constantly needs to be refreshed. We can do this by customizing the `useQuery` hook's `fetchPolicy`.

First, let's navigate to `src/pages/profile.tsx` and write our query:

<MultiCodeBlock>

```tsx:title=src/pages/profile.tsx
import React, { Fragment } from 'react'; // preserve-line
import { gql, useQuery } from '@apollo/client'; // preserve-line

import { Loading, Header, LaunchTile } from '../components'; // preserve-line
import { LAUNCH_TILE_DATA } from './launches'; // preserve-line
import { RouteComponentProps } from '@reach/router';
import * as GetMyTripsTypes from './__generated__/GetMyTrips';

export const GET_MY_TRIPS = gql`
  query GetMyTrips {
    me {
      id
      email
      trips {
        ...LaunchTile
      }
    }
  }
  ${LAUNCH_TILE_DATA}
`;
```

</MultiCodeBlock>

Next, let's render a component with `useQuery` to fetch a logged in user's list of trips. By default, Apollo Client's fetch policy is `cache-first`, which means it checks the cache to see if the result is there before making a network request. Since we want this list to always reflect the newest data from our graph API, we set the `fetchPolicy` for this query to `network-only`:

<MultiCodeBlock>

```tsx:title=src/pages/profile.tsx
interface ProfileProps extends RouteComponentProps {}

const Profile: React.FC<ProfileProps> = () => {
  const { data, loading, error } = useQuery<GetMyTripsTypes.GetMyTrips, any>(
    GET_MY_TRIPS,
    { fetchPolicy: "network-only" } // highlight-line
  );
  if (loading) return <Loading />;
  if (error) return <p>ERROR: {error.message}</p>;
  if (data === undefined) return <p>ERROR</p>;

  return (
    <Fragment>
      <Header>My Trips</Header>
      {data.me && data.me.trips.length ? (
        data.me.trips.map((launch: any) => (
          <LaunchTile key={launch.id} launch={launch} />
        ))
      ) : (
        <p>You haven't booked any trips</p>
      )}
    </Fragment>
  );
}

export default Profile;
```

</MultiCodeBlock>

If you try to render this query, you'll notice that it returns null. This is because we need to implement our login feature first. We're going to tackle login in the next section.

Now that we've learned how to leverage `useQuery` to build components that can fetch a paginated list, share fragments, and customize the fetch policy, it's time to progress to the next section so we can learn how to update data with mutations!
